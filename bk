import intersect;
import utils;
import safe_math;

struct SplatTetrahedraLinear : IDifferentiable
{
    Tetrahedra tet;
    // float4x3 vertex_color; // Per-vertex color to be barycentrically interpolated
    float3 base_color;
    float3 grd;
    float base_density;          // Single scalar density for the entire tetrahedron
    float3 d_grd;
};

// Given three vertex-colors (c0, c1, c2) and the barycentric coords (u,v)
//   w0 = u, w1 = v, w2 = 1 - u - v
// returns the final interpolated color:
[Differentiable]
float3 interpolate_triangle_color(
    float3 c0, float3 c1, float3 c2,
    float u, float v)
{
    float w0 = u;
    float w1 = v;
    float w2 = 1.0f - w0 - w1;
    return c0 * w0 + c1 * w1 + c2 * w2;
}

[Differentiable]
float4 tet_barycentric(float3 p, float4x3 vs)
{
    // Construct matrix T from tetrahedron vertices
    float3x3 T = float3x3(vs[0] - vs[3], vs[1] - vs[3], vs[2] - vs[3]);

    // Solve for (u, v, w)
    float3 uvw = SolveLinearSystem(T, p - vs[3]);

    // Compute t
    float t = 1.0 - uvw.x - uvw.y - uvw.z;

    return float4(uvw, t);
}

void print_verts(float4x3 verts) {
    printf("%f, %f, %f, %f\n", verts[0].x, verts[1].x, verts[2].x, verts[3].x);
}
void print_vec(float3 vec) {
    printf("(%f, %f, %f),", vec.x, vec.y, vec.z);
}

[Differentiable]
float3 _solve_integral(float a_s, float b_s_p, float3 A_c, float3 B_c_p, float t_start, float t_end)
{
    if (t_start >= t_end) return float3(0, 0, 0);

    float3 sc_c2 = a_s * A_c;
    float3 sc_c1 = a_s * B_c_p + b_s_p * A_c;
    float3 sc_c0 = b_s_p * B_c_p;

    float T_c2 = -0.5f * a_s;
    float T_c1 = -b_s_p;
    float T_c0 = 1.0f + 0.5f * a_s * t_start * t_start + b_s_p * t_start;

    float3 c4 = sc_c2 * T_c2;
    float3 c3 = sc_c2 * T_c1 + sc_c1 * T_c2;
    float3 c2 = sc_c2 * T_c0 + sc_c1 * T_c1 + sc_c0 * T_c2;
    float3 c1 = sc_c1 * T_c0 + sc_c0 * T_c1;
    float3 c0 = sc_c0 * T_c0;

    float t_end2 = t_end * t_end;
    float t_end3 = t_end2 * t_end;
    float t_end4 = t_end3 * t_end;
    float t_end5 = t_end4 * t_end;
    float3 int_end = c4 * (t_end5 * 0.2f) + c3 * (t_end4 * 0.25f) + c2 * (t_end3 / 3.0f) + c1 * (t_end2 * 0.5f) + c0 * t_end;

    float t_start2 = t_start * t_start;
    float t_start3 = t_start2 * t_start;
    float t_start4 = t_start3 * t_start;
    float t_start5 = t_start4 * t_start;
    float3 int_start = c4 * (t_start5 * 0.2f) + c3 * (t_start4 * 0.25f) + c2 * (t_start3 / 3.0f) + c1 * (t_start2 * 0.5f) + c0 * t_start;

    return int_end - int_start;
}

[Differentiable]
float4 solve_integral(
    float3 g_s, float b_s,
    // float3x3 G_c, float3 b_c,
    float3 G_c, float3 b_c,
    float3 r_o, float3 r_d,
    float delta_t)
{
    float a_s = dot(g_s, r_d);
    float b_s_p = dot(g_s, r_o) + b_s;
    float a_c = dot(G_c, r_d);
    float3 A_c = {a_c, a_c, a_c};
    float b_c = dot(G_c, r_o);
    float3 B_c_p = float3(b_c, b_c, b_c) + b_c;

    // Step 1: Find the interval [t_start_act, t_end_act] where s'(t) > 0.
    float t_start_act = 0.0f;
    float t_end_act = delta_t;

    if (b_s_p <= 0.0f && a_s <= 0.0f) return float4(0, 0, 0, 0);

    float t_zero = safe_div(-b_s_p, a_s);
    if (b_s_p < 0.0f && a_s > 0.0f) t_start_act = t_zero;
    if (b_s_p > 0.0f && a_s < 0.0f) t_end_act = t_zero;

    if (t_start_act >= delta_t) return float4(0, 0, 0, 0);
    t_end_act = min(t_end_act, delta_t);

    // Step 2: Find the intercept 'e_p' where transmittance T(t) becomes zero.
    float C_quad = -(1.0f + 0.5f * a_s * t_start_act * t_start_act + b_s_p * t_start_act);
    float dsc = b_s_p * b_s_p - 2.0f * a_s * C_quad;

    float e_p = t_end_act;
    if (dsc >= 0.0f)
    {
        float sqrt_d = sqrt(dsc);
        float r1 = safe_div(-b_s_p + sqrt_d, a_s);
        float r2 = safe_div(-b_s_p - sqrt_d, a_s);

        float min_root = 1.#INF;
        if (r1 > t_start_act - 1e-6f) min_root = r1;
        if (r2 > t_start_act - 1e-6f) min_root = min(min_root, r2);

        if (min_root < 1.#INF) e_p = min_root;
    }

    // Step 3: Determine the final integration range.
    float t_end_final = min(t_end_act, e_p);
    float alpha_start = a_s * t_end_final*t_end_final / 2.0 + b_s_p * t_end_final;
    float alpha_end = a_s * t_start_act*t_start_act / 2.0 + b_s_p * t_start_act;
    float alpha = alpha_end - alpha_start;

    // Step 4: Call the subfunction with the correct bounds.
    float3 c = _solve_integral(a_s, b_s_p, A_c, B_c_p, t_start_act, t_end_final);
    return {c.x, c.y, c.z, alpha}; 
}

[Differentiable]
inline float3 mix_color(float4x3 vertex_color, float4 bary) {
    return max(vertex_color[0] * bary.x + vertex_color[1] * bary.y + vertex_color[2] * bary.z + vertex_color[3] * bary.w, 0.f);
}

// [Differentiable]
// inline float3 linear_color(float4x3 grad, float3 v)
// {
//     // return grad[0] + grad[1] * v.x + grad[2] * v.y + grad[3] * v.z;
//     return {
//         max(grad[0].r + dot(grad[1], v), 0.f),
//         max(grad[0].g + dot(grad[2], v), 0.f),
//         max(grad[0].b + dot(grad[3], v), 0.f),
//     };
// }

[Differentiable]
inline float3 linear_color(float3 grad, float3 v)
{
    // return grad[0] + grad[1] * v.x + grad[2] * v.y + grad[3] * v.z;
    float f = dot(grad, v);
    return {f, f, f};
}

[Differentiable]
float3 compute_integral(float3 c0, float3 c1, float dt, float d) {
    float alpha = safe_exp(-d*dt);
    float X = (-d*dt*alpha + 1 - alpha);
    float Y = (d*dt-1) + alpha;
    return safe_div(X*c0+Y*c1, d*dt);
}


[Differentiable]
bool evaluate_tetra_linear(
    in SplatTetrahedraLinear g, 
    in float3 ray_o,
    in float3 ray_d,
    no_diff in float t_min,
    out CtrlPt ctrl_pt)
{
    float2 dist;

    float4x3 verts = float4x3(g.tet.verts[0], g.tet.verts[1], g.tet.verts[2], g.tet.verts[3]);

    bool hit = ray_tetrahedron_intersect_fused(
        ray_o, ray_d, verts, dist);

    float enter = dist.x;
    float exit = max(dist.y, enter);
    float dt = max(dist.y - enter, 0.0f);
    float intersection_t = 0.5*(exit+enter);

    if (!hit || dt < 1e-5f) {
        ctrl_pt = { (float4)(0.f, 0.f, 0.f, 0.f), {0.f, 0.f}, g.base_density };
        return false;
    } else {
        /*
        float3x3 T = transpose(float3x3(verts[0] - verts[3], verts[1] - verts[3], verts[2] - verts[3]));
        float3 uvw_enter = SolveLinearSystem(T, enter * ray_d + ray_o - verts[3]);
        float3 uvw_exit = SolveLinearSystem(T, exit * ray_d + ray_o - verts[3]);

        float w_enter = safe_clip(1.0 - uvw_enter.x - uvw_enter.y - uvw_enter.z, 0, 1);
        float w_exit = safe_clip(1.0 - uvw_exit.x - uvw_exit.y - uvw_exit.z, 0, 1);

        float4 b_enter = float4(uvw_enter, w_enter);
        float4 b_exit = float4(uvw_exit, w_exit);

        float3 c_enter = mix_color(g.vertex_color, b_enter);
        float3 c_exit = mix_color(g.vertex_color, b_exit);
        */

        float3 v_enter = enter * ray_d + ray_o - verts[0];
        float3 v_exit = exit * ray_d + ray_o - verts[0];
        float3 c_enter = max(linear_color(g.grd, v_enter) + g.base_color, 0.f);
        float3 c_exit = max(linear_color(g.grd, v_exit) + g.base_color, 0.f);
        // float a_s = dot(g.d_grd, ray_d);
        // float x = -safe_div(g.base_density, a_s);
        // if (abs(x) > 1e5 || dt < x) {
        //     x = dt;
        // }
        // float area = x * (g.base_density + a_s / 2);
        // float4 rgba1 = solve_integral(
        //     g.d_grd, g.base_density,
        //     g.grd, g.base_color,
        //     v_enter, ray_d,
        //     dt);

        float alpha = safe_clip(1.0f - safe_exp(-g.base_density * dt), 0.f, 1.f);
        // float alpha = safe_clip(1.0f - safe_exp(-area), 0.f, 1.f);
        float3 final_color = compute_integral(c_exit, c_enter, dt, g.base_density);

        float4 rgba = {c_enter.x,
                       c_enter.y,
                       c_enter.z,
                       alpha};
        ctrl_pt = { rgba, {enter, exit}, g.base_density };
        return true;
    }
}

////////////////////////////////////////////////////////////////////////////////
// 5) Loading functions for separate density & vertex colors
//    We add "_interp" suffix to keep the old ones intact.
////////////////////////////////////////////////////////////////////////////////

[Differentiable]
SplatTetrahedraLinear load_tet_alphablend_interp(
    int32_t        g_idx,
    DiffTensorView vertices,
    TensorView<int32_t> indices,
    DiffTensorView tet_density)
{
    no_diff uint4 virtual_tet = load_virtual_tetrahedra(g_idx, indices);
    Tetrahedra tet    = load_tetrahedra(vertices, virtual_tet);

    // Here we assume each tetrahedron has a single scalar density in tet_density:
    float base_density = float(tet_density[g_idx, 0]);
    float3 base_color = {
        float(tet_density[g_idx, 1]),
        float(tet_density[g_idx, 2]),
        float(tet_density[g_idx, 3]),
    };
    float3 grd = {
        float(tet_density[g_idx, 4]),
        float(tet_density[g_idx, 5]),
        float(tet_density[g_idx, 6]),
    };
    float3 d_grd = {
        float(tet_density[g_idx, 7]),
        float(tet_density[g_idx, 8]),
        float(tet_density[g_idx, 9]),
    };

    SplatTetrahedraLinear result = {
        tet, base_color, grd, base_density, d_grd
    };
    return result;
}

// Non-diff version (if needed)
SplatTetrahedraLinear load_tet_alphablend_interp(
    int32_t        g_idx,
    TensorView<float> vertices,
    TensorView<int32_t> indices,
    TensorView<float>  tet_density)
{
    uint4 virtual_tet = load_virtual_tetrahedra(g_idx, indices);
    Tetrahedra tet    = load_tetrahedra(vertices, virtual_tet);

    SplatTetrahedraLinear result;
    result.tet       = tet;
    result.base_density   = float(tet_density[g_idx, 0]);
    result.base_color = {
        float(tet_density[g_idx, 1]),
        float(tet_density[g_idx, 2]),
        float(tet_density[g_idx, 3]),
    };
    result.grd = {
        float(tet_density[g_idx, 4]),
        float(tet_density[g_idx, 5]),
        float(tet_density[g_idx, 6]),
    };
    result.d_grd = {
        float(tet_density[g_idx, 7]),
        float(tet_density[g_idx, 8]),
        float(tet_density[g_idx, 9]),
    };
    return result;
}

